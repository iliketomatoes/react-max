/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * AIG Dashboard API
 * This is a sample API server
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:8080/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Entities
 */
export interface Entities {
    /**
     * 
     * @type {Array&lt;Entity&gt;}
     * @memberof Entities
     */
    data?: Array<Entity>;
}

/**
 * 
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    entityId?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    entityName?: string;
}

/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    eventId?: number;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    eventName?: string;
}

/**
 * 
 * @export
 * @interface Events
 */
export interface Events {
    /**
     * 
     * @type {Array&lt;Event&gt;}
     * @memberof Events
     */
    data?: Array<Event>;
}

/**
 * 
 * @export
 * @interface Exposure
 */
export interface Exposure {
    /**
     * 
     * @type {number}
     * @memberof Exposure
     */
    aIGCreditExposure?: number;
    /**
     * 
     * @type {number}
     * @memberof Exposure
     */
    invtCmtCreditExposure?: number;
}

/**
 * 
 * @export
 * @interface Exposures
 */
export interface Exposures {
    /**
     * 
     * @type {Array&lt;Exposure&gt;}
     * @memberof Exposures
     */
    data?: Array<Exposure>;
}

/**
 * 
 * @export
 * @interface KeyIndicator
 */
export interface KeyIndicator {
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    eBITDACapExInterestExpense?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    eBITDAInterestExpenseRentExpense?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    eBITDAInterestExpense?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    fCFEBITDAe?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    fCFTotalDebt?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    fFOInterest?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    fFOTotalDebt?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    fixedChargeCoverage?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    leaseAdjustedDebt8xEBITDAR?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    netDebtEBITDA?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    nextDebtCapitalization?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    pensionAdjustedDebtAdjEBITDA?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    securedDebtEBITDA?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    totalDebtCapitalization?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    totalDebtEBITDA?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyIndicator
     */
    totalDebtFFO?: number;
}

/**
 * 
 * @export
 * @interface KeyIndicators
 */
export interface KeyIndicators {
    /**
     * 
     * @type {Array&lt;KeyIndicator&gt;}
     * @memberof KeyIndicators
     */
    data?: Array<KeyIndicator>;
}

/**
 * 
 * @export
 * @interface Limit
 */
export interface Limit {
    /**
     * 
     * @type {number}
     * @memberof Limit
     */
    aIGLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof Limit
     */
    analystConstraint?: number;
    /**
     * 
     * @type {number}
     * @memberof Limit
     */
    totalCapacity?: number;
}

/**
 * 
 * @export
 * @interface Limits
 */
export interface Limits {
    /**
     * 
     * @type {Array&lt;Limit&gt;}
     * @memberof Limits
     */
    data?: Array<Limit>;
}

/**
 * 
 * @export
 * @interface Portfolio
 */
export interface Portfolio {
    /**
     * 
     * @type {string}
     * @memberof Portfolio
     */
    portfolioName?: string;
}

/**
 * 
 * @export
 * @interface Portfolios
 */
export interface Portfolios {
    /**
     * 
     * @type {Array&lt;Portfolio&gt;}
     * @memberof Portfolios
     */
    data?: Array<Portfolio>;
}

/**
 * 
 * @export
 * @interface Rating
 */
export interface Rating {
    /**
     * 
     * @type {number}
     * @memberof Rating
     */
    ratingId?: number;
    /**
     * 
     * @type {number}
     * @memberof Rating
     */
    ratingValue?: number;
}

/**
 * 
 * @export
 * @interface Ratings
 */
export interface Ratings {
    /**
     * 
     * @type {Array&lt;Rating&gt;}
     * @memberof Ratings
     */
    data?: Array<Rating>;
}

/**
 * 
 * @export
 * @interface Sector
 */
export interface Sector {
    /**
     * 
     * @type {string}
     * @memberof Sector
     */
    sectorName?: string;
}

/**
 * 
 * @export
 * @interface Sectors
 */
export interface Sectors {
    /**
     * 
     * @type {Array&lt;Sector&gt;}
     * @memberof Sectors
     */
    data?: Array<Sector>;
}

/**
 * 
 * @export
 * @interface Stories
 */
export interface Stories {
    /**
     * 
     * @type {number}
     * @memberof Stories
     */
    storyGroupsPerPage?: number;
    /**
     * 
     * @type {number}
     * @memberof Stories
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof Stories
     */
    totalStoryGroups?: number;
    /**
     * 
     * @type {Array&lt;Story&gt;}
     * @memberof Stories
     */
    data?: Array<Story>;
}

/**
 * 
 * @export
 * @interface Story
 */
export interface Story {
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    DJ_ID?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    dominantNewsId?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    entity?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    entityId?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    headline?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    newsGroupId?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    sector?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    similarNewsIds?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    time?: string;
}

/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    token: string;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    userId?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstNm?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastNm?: string;
}


/**
 * EntitiesApi - fetch parameter creator
 * @export
 */
export const EntitiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntities(options: any = {}): FetchArgs {
            const localVarPath = `/entities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search entities
         * @param {string} query The string to search entities with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEntities(query: string, options: any = {}): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling searchEntities.');
            }
            const localVarPath = `/entity/search/{query}`
                .replace(`{${"query"}}`, encodeURIComponent(String(query)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntitiesApi - functional programming interface
 * @export
 */
export const EntitiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntities(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Entities> {
            const localVarFetchArgs = EntitiesApiFetchParamCreator(configuration).getEntities(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Search entities
         * @param {string} query The string to search entities with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEntities(query: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Entities>> {
            const localVarFetchArgs = EntitiesApiFetchParamCreator(configuration).searchEntities(query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EntitiesApi - factory interface
 * @export
 */
export const EntitiesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntities(options?: any) {
            return EntitiesApiFp(configuration).getEntities(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Search entities
         * @param {string} query The string to search entities with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEntities(query: string, options?: any) {
            return EntitiesApiFp(configuration).searchEntities(query, options)(fetch, basePath);
        },
    };
};

/**
 * EntitiesApi - object-oriented interface
 * @export
 * @class EntitiesApi
 * @extends {BaseAPI}
 */
export class EntitiesApi extends BaseAPI {
    /**
     * 
     * @summary Get entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntities(options?: any) {
        return EntitiesApiFp(this.configuration).getEntities(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Search entities
     * @param {} query The string to search entities with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public searchEntities(query: string, options?: any) {
        return EntitiesApiFp(this.configuration).searchEntities(query, options)(this.fetch, this.basePath);
    }

}

/**
 * EventsApi - fetch parameter creator
 * @export
 */
export const EventsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(options: any = {}): FetchArgs {
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search events
         * @param {string} query The string to search entities with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEvents(query: string, options: any = {}): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling searchEvents.');
            }
            const localVarPath = `/event/search/{query}`
                .replace(`{${"query"}}`, encodeURIComponent(String(query)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Events> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).getEvents(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Search events
         * @param {string} query The string to search entities with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEvents(query: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Events>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).searchEvents(query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(options?: any) {
            return EventsApiFp(configuration).getEvents(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Search events
         * @param {string} query The string to search entities with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEvents(query: string, options?: any) {
            return EventsApiFp(configuration).searchEvents(query, options)(fetch, basePath);
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary Get events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvents(options?: any) {
        return EventsApiFp(this.configuration).getEvents(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Search events
     * @param {} query The string to search entities with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public searchEvents(query: string, options?: any) {
        return EventsApiFp(this.configuration).searchEvents(query, options)(this.fetch, this.basePath);
    }

}

/**
 * PortfoliosApi - fetch parameter creator
 * @export
 */
export const PortfoliosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get portfolios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolios(options: any = {}): FetchArgs {
            const localVarPath = `/portfolios`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfoliosApi - functional programming interface
 * @export
 */
export const PortfoliosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get portfolios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolios(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Portfolios> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).getPortfolios(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PortfoliosApi - factory interface
 * @export
 */
export const PortfoliosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get portfolios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolios(options?: any) {
            return PortfoliosApiFp(configuration).getPortfolios(options)(fetch, basePath);
        },
    };
};

/**
 * PortfoliosApi - object-oriented interface
 * @export
 * @class PortfoliosApi
 * @extends {BaseAPI}
 */
export class PortfoliosApi extends BaseAPI {
    /**
     * 
     * @summary Get portfolios
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public getPortfolios(options?: any) {
        return PortfoliosApiFp(this.configuration).getPortfolios(options)(this.fetch, this.basePath);
    }

}

/**
 * SectorsApi - fetch parameter creator
 * @export
 */
export const SectorsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get sectors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectors(options: any = {}): FetchArgs {
            const localVarPath = `/sectors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SectorsApi - functional programming interface
 * @export
 */
export const SectorsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get sectors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectors(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Sectors> {
            const localVarFetchArgs = SectorsApiFetchParamCreator(configuration).getSectors(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SectorsApi - factory interface
 * @export
 */
export const SectorsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get sectors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectors(options?: any) {
            return SectorsApiFp(configuration).getSectors(options)(fetch, basePath);
        },
    };
};

/**
 * SectorsApi - object-oriented interface
 * @export
 * @class SectorsApi
 * @extends {BaseAPI}
 */
export class SectorsApi extends BaseAPI {
    /**
     * 
     * @summary Get sectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectorsApi
     */
    public getSectors(options?: any) {
        return SectorsApiFp(this.configuration).getSectors(options)(this.fetch, this.basePath);
    }

}

/**
 * StoriesApi - fetch parameter creator
 * @export
 */
export const StoriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get stories count
         * @param {string} [entityId] Get a specific page entity id
         * @param {boolean} [pageCountOnly] Get only the page count info
         * @param {number} [pageNo] Get a specific page
         * @param {number} [portfolioNm] Get by portfolio name
         * @param {string} [sectorNm] Get by sector name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStories(entityId?: string, pageCountOnly?: boolean, pageNo?: number, portfolioNm?: number, sectorNm?: string, options: any = {}): FetchArgs {
            const localVarPath = `/stories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (entityId !== undefined) {
                localVarQueryParameter['entity_id'] = entityId;
            }

            if (pageCountOnly !== undefined) {
                localVarQueryParameter['page_count_only'] = pageCountOnly;
            }

            if (pageNo !== undefined) {
                localVarQueryParameter['page_no'] = pageNo;
            }

            if (portfolioNm !== undefined) {
                localVarQueryParameter['portfolio_nm'] = portfolioNm;
            }

            if (sectorNm !== undefined) {
                localVarQueryParameter['sector_nm'] = sectorNm;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get story
         * @param {string} id The story id to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStory(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStory.');
            }
            const localVarPath = `/story/details/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get story entities
         * @param {string} id The id to get entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryEntities(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStoryEntities.');
            }
            const localVarPath = `/story/entities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get story events
         * @param {string} id The id to get events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryEvents(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStoryEvents.');
            }
            const localVarPath = `/story/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get story exposures
         * @param {string} id The id to get exposures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryExposures(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStoryExposures.');
            }
            const localVarPath = `/story/exposures/entity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get story key indicators
         * @param {string} id The id to get key indicators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryKeyIndicators(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStoryKeyIndicators.');
            }
            const localVarPath = `/story/key_indicators/entity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get story limits
         * @param {string} id The id to get limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryLimits(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStoryLimits.');
            }
            const localVarPath = `/story/limits/entity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get story entities by user
         * @param {string} id The id to get entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryUserEntities(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStoryUserEntities.');
            }
            const localVarPath = `/story/user/entities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post entities by user
         * @param {number} newsId Select news id
         * @param {Array&lt;string&gt;} entityIds Set entity ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStoryEntities(newsId: number, entityIds: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'newsId' is not null or undefined
            if (newsId === null || newsId === undefined) {
                throw new RequiredError('newsId','Required parameter newsId was null or undefined when calling postStoryEntities.');
            }
            // verify required parameter 'entityIds' is not null or undefined
            if (entityIds === null || entityIds === undefined) {
                throw new RequiredError('entityIds','Required parameter entityIds was null or undefined when calling postStoryEntities.');
            }
            const localVarPath = `/story/user/entities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (newsId !== undefined) {
                localVarQueryParameter['news_id'] = newsId;
            }

            if (entityIds) {
                localVarQueryParameter['entity_ids'] = entityIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post events by user
         * @param {number} newsId Select news id
         * @param {Array&lt;string&gt;} eventIds Set event ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStoryEvents(newsId: number, eventIds: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'newsId' is not null or undefined
            if (newsId === null || newsId === undefined) {
                throw new RequiredError('newsId','Required parameter newsId was null or undefined when calling postStoryEvents.');
            }
            // verify required parameter 'eventIds' is not null or undefined
            if (eventIds === null || eventIds === undefined) {
                throw new RequiredError('eventIds','Required parameter eventIds was null or undefined when calling postStoryEvents.');
            }
            const localVarPath = `/story/user/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (newsId !== undefined) {
                localVarQueryParameter['news_id'] = newsId;
            }

            if (eventIds) {
                localVarQueryParameter['event_ids'] = eventIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post ratings by user
         * @param {number} newsId Select news id
         * @param {number} userRating Set user rating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStoryRatings(newsId: number, userRating: number, options: any = {}): FetchArgs {
            // verify required parameter 'newsId' is not null or undefined
            if (newsId === null || newsId === undefined) {
                throw new RequiredError('newsId','Required parameter newsId was null or undefined when calling postStoryRatings.');
            }
            // verify required parameter 'userRating' is not null or undefined
            if (userRating === null || userRating === undefined) {
                throw new RequiredError('userRating','Required parameter userRating was null or undefined when calling postStoryRatings.');
            }
            const localVarPath = `/story/user/ratings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (newsId !== undefined) {
                localVarQueryParameter['news_id'] = newsId;
            }

            if (userRating !== undefined) {
                localVarQueryParameter['user_rating'] = userRating;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoriesApi - functional programming interface
 * @export
 */
export const StoriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get stories count
         * @param {string} [entityId] Get a specific page entity id
         * @param {boolean} [pageCountOnly] Get only the page count info
         * @param {number} [pageNo] Get a specific page
         * @param {number} [portfolioNm] Get by portfolio name
         * @param {string} [sectorNm] Get by sector name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStories(entityId?: string, pageCountOnly?: boolean, pageNo?: number, portfolioNm?: number, sectorNm?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Stories> {
            const localVarFetchArgs = StoriesApiFetchParamCreator(configuration).getStories(entityId, pageCountOnly, pageNo, portfolioNm, sectorNm, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get story
         * @param {string} id The story id to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStory(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Stories> {
            const localVarFetchArgs = StoriesApiFetchParamCreator(configuration).getStory(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get story entities
         * @param {string} id The id to get entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryEntities(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Entities> {
            const localVarFetchArgs = StoriesApiFetchParamCreator(configuration).getStoryEntities(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get story events
         * @param {string} id The id to get events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryEvents(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Events> {
            const localVarFetchArgs = StoriesApiFetchParamCreator(configuration).getStoryEvents(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get story exposures
         * @param {string} id The id to get exposures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryExposures(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Exposures> {
            const localVarFetchArgs = StoriesApiFetchParamCreator(configuration).getStoryExposures(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get story key indicators
         * @param {string} id The id to get key indicators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryKeyIndicators(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyIndicators> {
            const localVarFetchArgs = StoriesApiFetchParamCreator(configuration).getStoryKeyIndicators(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get story limits
         * @param {string} id The id to get limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryLimits(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Limits> {
            const localVarFetchArgs = StoriesApiFetchParamCreator(configuration).getStoryLimits(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get story entities by user
         * @param {string} id The id to get entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryUserEntities(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Entities> {
            const localVarFetchArgs = StoriesApiFetchParamCreator(configuration).getStoryUserEntities(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Post entities by user
         * @param {number} newsId Select news id
         * @param {Array&lt;string&gt;} entityIds Set entity ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStoryEntities(newsId: number, entityIds: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Entities> {
            const localVarFetchArgs = StoriesApiFetchParamCreator(configuration).postStoryEntities(newsId, entityIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Post events by user
         * @param {number} newsId Select news id
         * @param {Array&lt;string&gt;} eventIds Set event ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStoryEvents(newsId: number, eventIds: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Events> {
            const localVarFetchArgs = StoriesApiFetchParamCreator(configuration).postStoryEvents(newsId, eventIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Post ratings by user
         * @param {number} newsId Select news id
         * @param {number} userRating Set user rating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStoryRatings(newsId: number, userRating: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ratings> {
            const localVarFetchArgs = StoriesApiFetchParamCreator(configuration).postStoryRatings(newsId, userRating, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StoriesApi - factory interface
 * @export
 */
export const StoriesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get stories count
         * @param {string} [entityId] Get a specific page entity id
         * @param {boolean} [pageCountOnly] Get only the page count info
         * @param {number} [pageNo] Get a specific page
         * @param {number} [portfolioNm] Get by portfolio name
         * @param {string} [sectorNm] Get by sector name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStories(entityId?: string, pageCountOnly?: boolean, pageNo?: number, portfolioNm?: number, sectorNm?: string, options?: any) {
            return StoriesApiFp(configuration).getStories(entityId, pageCountOnly, pageNo, portfolioNm, sectorNm, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get story
         * @param {string} id The story id to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStory(id: string, options?: any) {
            return StoriesApiFp(configuration).getStory(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get story entities
         * @param {string} id The id to get entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryEntities(id: string, options?: any) {
            return StoriesApiFp(configuration).getStoryEntities(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get story events
         * @param {string} id The id to get events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryEvents(id: string, options?: any) {
            return StoriesApiFp(configuration).getStoryEvents(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get story exposures
         * @param {string} id The id to get exposures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryExposures(id: string, options?: any) {
            return StoriesApiFp(configuration).getStoryExposures(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get story key indicators
         * @param {string} id The id to get key indicators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryKeyIndicators(id: string, options?: any) {
            return StoriesApiFp(configuration).getStoryKeyIndicators(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get story limits
         * @param {string} id The id to get limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryLimits(id: string, options?: any) {
            return StoriesApiFp(configuration).getStoryLimits(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get story entities by user
         * @param {string} id The id to get entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoryUserEntities(id: string, options?: any) {
            return StoriesApiFp(configuration).getStoryUserEntities(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Post entities by user
         * @param {number} newsId Select news id
         * @param {Array&lt;string&gt;} entityIds Set entity ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStoryEntities(newsId: number, entityIds: Array<string>, options?: any) {
            return StoriesApiFp(configuration).postStoryEntities(newsId, entityIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Post events by user
         * @param {number} newsId Select news id
         * @param {Array&lt;string&gt;} eventIds Set event ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStoryEvents(newsId: number, eventIds: Array<string>, options?: any) {
            return StoriesApiFp(configuration).postStoryEvents(newsId, eventIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Post ratings by user
         * @param {number} newsId Select news id
         * @param {number} userRating Set user rating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStoryRatings(newsId: number, userRating: number, options?: any) {
            return StoriesApiFp(configuration).postStoryRatings(newsId, userRating, options)(fetch, basePath);
        },
    };
};

/**
 * StoriesApi - object-oriented interface
 * @export
 * @class StoriesApi
 * @extends {BaseAPI}
 */
export class StoriesApi extends BaseAPI {
    /**
     * 
     * @summary Get stories count
     * @param {} [entityId] Get a specific page entity id
     * @param {} [pageCountOnly] Get only the page count info
     * @param {} [pageNo] Get a specific page
     * @param {} [portfolioNm] Get by portfolio name
     * @param {} [sectorNm] Get by sector name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoriesApi
     */
    public getStories(entityId?: string, pageCountOnly?: boolean, pageNo?: number, portfolioNm?: number, sectorNm?: string, options?: any) {
        return StoriesApiFp(this.configuration).getStories(entityId, pageCountOnly, pageNo, portfolioNm, sectorNm, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get story
     * @param {} id The story id to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoriesApi
     */
    public getStory(id: string, options?: any) {
        return StoriesApiFp(this.configuration).getStory(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get story entities
     * @param {} id The id to get entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoriesApi
     */
    public getStoryEntities(id: string, options?: any) {
        return StoriesApiFp(this.configuration).getStoryEntities(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get story events
     * @param {} id The id to get events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoriesApi
     */
    public getStoryEvents(id: string, options?: any) {
        return StoriesApiFp(this.configuration).getStoryEvents(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get story exposures
     * @param {} id The id to get exposures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoriesApi
     */
    public getStoryExposures(id: string, options?: any) {
        return StoriesApiFp(this.configuration).getStoryExposures(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get story key indicators
     * @param {} id The id to get key indicators
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoriesApi
     */
    public getStoryKeyIndicators(id: string, options?: any) {
        return StoriesApiFp(this.configuration).getStoryKeyIndicators(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get story limits
     * @param {} id The id to get limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoriesApi
     */
    public getStoryLimits(id: string, options?: any) {
        return StoriesApiFp(this.configuration).getStoryLimits(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get story entities by user
     * @param {} id The id to get entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoriesApi
     */
    public getStoryUserEntities(id: string, options?: any) {
        return StoriesApiFp(this.configuration).getStoryUserEntities(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Post entities by user
     * @param {} newsId Select news id
     * @param {} entityIds Set entity ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoriesApi
     */
    public postStoryEntities(newsId: number, entityIds: Array<string>, options?: any) {
        return StoriesApiFp(this.configuration).postStoryEntities(newsId, entityIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Post events by user
     * @param {} newsId Select news id
     * @param {} eventIds Set event ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoriesApi
     */
    public postStoryEvents(newsId: number, eventIds: Array<string>, options?: any) {
        return StoriesApiFp(this.configuration).postStoryEvents(newsId, eventIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Post ratings by user
     * @param {} newsId Select news id
     * @param {} userRating Set user rating
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoriesApi
     */
    public postStoryRatings(newsId: number, userRating: number, options?: any) {
        return StoriesApiFp(this.configuration).postStoryRatings(newsId, userRating, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options: any = {}): FetchArgs {
            const localVarPath = `/user/profile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} email The email for login
         * @param {string} password The password for login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(email: string, password: string, options: any = {}): FetchArgs {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling loginUser.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling loginUser.');
            }
            const localVarPath = `/user/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options: any = {}): FetchArgs {
            const localVarPath = `/user/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} email The email for login
         * @param {string} password The password for login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(email: string, password: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Token> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).loginUser(email, password, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).logoutUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any) {
            return UsersApiFp(configuration).getUser(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} email The email for login
         * @param {string} password The password for login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(email: string, password: string, options?: any) {
            return UsersApiFp(configuration).loginUser(email, password, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: any) {
            return UsersApiFp(configuration).logoutUser(options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Get user details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(options?: any) {
        return UsersApiFp(this.configuration).getUser(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Logs user into the system
     * @param {} email The email for login
     * @param {} password The password for login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public loginUser(email: string, password: string, options?: any) {
        return UsersApiFp(this.configuration).loginUser(email, password, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Logs out current logged in user session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public logoutUser(options?: any) {
        return UsersApiFp(this.configuration).logoutUser(options)(this.fetch, this.basePath);
    }

}

